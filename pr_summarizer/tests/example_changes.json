[
  {
    "filename": "src/payment/processor.py",
    "status": "modified",
    "additions": 42,
    "deletions": 18,
    "diff": "@@ -1,12 +1,15 @@\n import logging\n import requests\n from decimal import Decimal\n+from typing import Dict, Optional\n+from dataclasses import dataclass\n from .exceptions import PaymentError, ValidationError\n \n logger = logging.getLogger(__name__)\n \n+@dataclass\n+class PaymentResult:\n+    success: bool\n+    transaction_id: Optional[str]\n+    error_message: Optional[str] = None\n+\n class PaymentProcessor:\n     \"\"\"Handles payment processing with external gateway.\"\"\"\n     \n@@ -15,23 +18,35 @@ class PaymentProcessor:\n         self.api_key = api_key\n         self.base_url = \"https://api.paymentgateway.com/v1\"\n         self.timeout = 30\n+        self.retry_attempts = 3\n     \n-    def process_payment(self, amount: float, card_token: str) -> dict:\n-        \"\"\"Process a payment transaction.\"\"\"\n+    def process_payment(self, amount: Decimal, card_token: str, customer_id: str) -> PaymentResult:\n+        \"\"\"Process a payment transaction with retry logic.\"\"\"\n         if amount <= 0:\n             raise ValidationError(\"Amount must be positive\")\n         \n+        for attempt in range(self.retry_attempts):\n+            try:\n+                return self._attempt_payment(amount, card_token, customer_id)\n+            except requests.RequestException as e:\n+                if attempt == self.retry_attempts - 1:\n+                    logger.error(f\"Payment failed after {self.retry_attempts} attempts: {e}\")\n+                    return PaymentResult(success=False, transaction_id=None, error_message=str(e))\n+                logger.warning(f\"Payment attempt {attempt + 1} failed, retrying...\")\n+    \n+    def _attempt_payment(self, amount: Decimal, card_token: str, customer_id: str) -> PaymentResult:\n+        \"\"\"Single payment attempt.\"\"\"\n         payload = {\n-            \"amount\": amount,\n+            \"amount\": str(amount),\n             \"currency\": \"USD\",\n-            \"card_token\": card_token\n+            \"card_token\": card_token,\n+            \"customer_id\": customer_id,\n+            \"idempotency_key\": f\"{customer_id}_{card_token}_{amount}\"\n         }\n         \n         try:\n             response = requests.post(\n                 f\"{self.base_url}/charges\",\n                 json=payload,\n                 headers={\"Authorization\": f\"Bearer {self.api_key}\"},\n-                timeout=self.timeout\n+                timeout=self.timeout\n             )\n             response.raise_for_status()\n             data = response.json()\n@@ -39,10 +54,12 @@ class PaymentProcessor:\n             logger.info(f\"Payment processed successfully: {data['id']}\")\n-            return data\n+            return PaymentResult(\n+                success=True,\n+                transaction_id=data['id']\n+            )\n         except requests.RequestException as e:\n             logger.error(f\"Payment processing failed: {e}\")\n-            raise PaymentError(f\"Payment failed: {e}\")\n+            raise"
  },
  {
    "filename": "src/api/routes/orders.py",
    "status": "added",
    "additions": 87,
    "deletions": 0,
    "diff": "@@ -0,0 +1,87 @@\n+from flask import Blueprint, request, jsonify\n+from flask_jwt_extended import jwt_required, get_jwt_identity\n+from marshmallow import ValidationError\n+import logging\n+\n+from ..schemas import OrderCreateSchema, OrderResponseSchema\n+from ..models import Order, OrderItem, db\n+from ..services import OrderService, PaymentService\n+from ..exceptions import OrderNotFoundError, InsufficientStockError\n+\n+logger = logging.getLogger(__name__)\norders_bp = Blueprint('orders', __name__, url_prefix='/api/orders')\n+\n+@orders_bp.route('', methods=['POST'])\n+@jwt_required()\n+def create_order():\n+    \"\"\"Create a new order with payment processing.\"\"\"\n+    try:\n+        user_id = get_jwt_identity()\n+        schema = OrderCreateSchema()\n+        data = schema.load(request.json)\n+        \n+        # Create order through service\n+        order_service = OrderService()\n+        order = order_service.create_order(\n+            user_id=user_id,\n+            items=data['items'],\n+            shipping_address=data['shipping_address'],\n+            payment_method=data['payment_method']\n+        )\n+        \n+        # Process payment\n+        payment_service = PaymentService()\n+        payment_result = payment_service.process_order_payment(order)\n+        \n+        if not payment_result.success:\n+            order_service.cancel_order(order.id)\n+            return jsonify({\n+                'error': 'Payment failed',\n+                'message': payment_result.error_message\n+            }), 402\n+        \n+        order.payment_status = 'completed'\n+        order.transaction_id = payment_result.transaction_id\n+        db.session.commit()\n+        \n+        logger.info(f\"Order {order.id} created successfully for user {user_id}\")\n+        \n+        schema = OrderResponseSchema()\n+        return jsonify(schema.dump(order)), 201\n+        \n+    except ValidationError as e:\n+        return jsonify({'error': 'Invalid data', 'details': e.messages}), 400\n+    except InsufficientStockError as e:\n+        return jsonify({'error': 'Insufficient stock', 'message': str(e)}), 409\n+    except Exception as e:\n+        logger.error(f\"Order creation failed: {e}\")\n+        return jsonify({'error': 'Internal server error'}), 500\n+\n+@orders_bp.route('/<int:order_id>', methods=['GET'])\n+@jwt_required()\n+def get_order(order_id):\n+    \"\"\"Get order details by ID.\"\"\"\n+    try:\n+        user_id = get_jwt_identity()\n+        order = Order.query.filter_by(id=order_id, user_id=user_id).first()\n+        \n+        if not order:\n+            return jsonify({'error': 'Order not found'}), 404\n+        \n+        schema = OrderResponseSchema()\n+        return jsonify(schema.dump(order))\n+        \n+    except Exception as e:\n+        logger.error(f\"Failed to retrieve order {order_id}: {e}\")\n+        return jsonify({'error': 'Internal server error'}), 500\n+\n+@orders_bp.route('', methods=['GET'])\n+@jwt_required()\n+def list_orders():\n+    \"\"\"List user's orders with pagination.\"\"\"\n+    try:\n+        user_id = get_jwt_identity()\n+        page = request.args.get('page', 1, type=int)\n+        per_page = min(request.args.get('per_page', 10, type=int), 100)\n+        \n+        orders = Order.query.filter_by(user_id=user_id)\\\n+                           .order_by(Order.created_at.desc())\\\n+                           .paginate(page=page, per_page=per_page)\n+        \n+        schema = OrderResponseSchema(many=True)\n+        return jsonify({\n+            'orders': schema.dump(orders.items),\n+            'pagination': {\n+                'page': page,\n+                'pages': orders.pages,\n+                'total': orders.total\n+            }\n+        })\n+        \n+    except Exception as e:\n+        logger.error(f\"Failed to list orders for user {user_id}: {e}\")\n+        return jsonify({'error': 'Internal server error'}), 500"
  },
  {
    "filename": "frontend/src/components/OrderSummary.tsx",
    "status": "modified",
    "additions": 28,
    "deletions": 12,
    "diff": "@@ -1,8 +1,10 @@\n import React from 'react';\n import { Card, CardContent, Typography, Divider } from '@mui/material';\n+import { LoadingButton } from '@mui/lab';\n+import { ShoppingCart, CreditCard } from '@mui/icons-material';\n import { formatCurrency } from '../utils/currency';\n \n interface OrderSummaryProps {\n   items: CartItem[];\n   subtotal: number;\n   tax: number;\n   shipping: number;\n+  onCheckout: () => Promise<void>;\n+  isProcessing?: boolean;\n }\n \n-export const OrderSummary: React.FC<OrderSummaryProps> = ({ items, subtotal, tax, shipping }) => {\n+export const OrderSummary: React.FC<OrderSummaryProps> = ({ \n+  items, \n+  subtotal, \n+  tax, \n+  shipping, \n+  onCheckout,\n+  isProcessing = false \n+}) => {\n   const total = subtotal + tax + shipping;\n \n   return (\n-    <Card sx={{ minWidth: 300 }}>\n+    <Card sx={{ minWidth: 300, position: 'sticky', top: 20 }}>\n       <CardContent>\n-        <Typography variant=\"h6\" gutterBottom>\n+        <Typography variant=\"h6\" gutterBottom sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>\n+          <ShoppingCart />\n           Order Summary\n         </Typography>\n         \n@@ -25,8 +35,20 @@ export const OrderSummary: React.FC<OrderSummaryProps> = ({ items, subtotal, ta\n         <Divider sx={{ my: 1 }} />\n         \n         <Typography variant=\"h6\" sx={{ fontWeight: 'bold' }}>\n           Total: {formatCurrency(total)}\n         </Typography>\n+        \n+        <LoadingButton\n+          fullWidth\n+          variant=\"contained\"\n+          size=\"large\"\n+          loading={isProcessing}\n+          loadingPosition=\"start\"\n+          startIcon={<CreditCard />}\n+          onClick={onCheckout}\n+          sx={{ mt: 2 }}\n+        >\n+          {isProcessing ? 'Processing...' : 'Proceed to Checkout'}\n+        </LoadingButton>\n       </CardContent>\n     </Card>\n   );\n };"
  },
  {
    "filename": "tests/test_payment_integration.py",
    "status": "added",
    "additions": 156,
    "deletions": 0,
    "diff": "@@ -0,0 +1,156 @@\n+import pytest\n+import responses\n+from decimal import Decimal\n+from unittest.mock import patch, MagicMock\n+\n+from src.payment.processor import PaymentProcessor, PaymentResult\n+from src.payment.exceptions import ValidationError\n+\n+@pytest.fixture\n+def payment_processor():\n+    return PaymentProcessor(api_key=\"test_key_123\")\n+\n+@pytest.fixture\n+def mock_successful_response():\n+    return {\n+        \"id\": \"txn_1234567890\",\n+        \"status\": \"succeeded\",\n+        \"amount\": \"99.99\",\n+        \"currency\": \"USD\",\n+        \"created\": \"2023-12-01T10:00:00Z\"\n+    }\n+\nclass TestPaymentProcessor:\n+    \"\"\"Test payment processing functionality.\"\"\"\n+    \n+    @responses.activate\n+    def test_successful_payment(self, payment_processor, mock_successful_response):\n+        \"\"\"Test successful payment processing.\"\"\"\n+        responses.add(\n+            responses.POST,\n+            \"https://api.paymentgateway.com/v1/charges\",\n+            json=mock_successful_response,\n+            status=200\n+        )\n+        \n+        result = payment_processor.process_payment(\n+            amount=Decimal('99.99'),\n+            card_token='tok_test_card',\n+            customer_id='cust_123'\n+        )\n+        \n+        assert result.success is True\n+        assert result.transaction_id == \"txn_1234567890\"\n+        assert result.error_message is None\n+    \n+    def test_invalid_amount(self, payment_processor):\n+        \"\"\"Test validation error for invalid amount.\"\"\"\n+        with pytest.raises(ValidationError, match=\"Amount must be positive\"):\n+            payment_processor.process_payment(\n+                amount=Decimal('-10.00'),\n+                card_token='tok_test_card',\n+                customer_id='cust_123'\n+            )\n+    \n+    @responses.activate\n+    def test_payment_gateway_error(self, payment_processor):\n+        \"\"\"Test handling of payment gateway errors.\"\"\"\n+        responses.add(\n+            responses.POST,\n+            \"https://api.paymentgateway.com/v1/charges\",\n+            json={\"error\": \"Card declined\"},\n+            status=402\n+        )\n+        \n+        result = payment_processor.process_payment(\n+            amount=Decimal('99.99'),\n+            card_token='tok_declined_card',\n+            customer_id='cust_123'\n+        )\n+        \n+        assert result.success is False\n+        assert result.transaction_id is None\n+        assert \"Card declined\" in result.error_message\n+    \n+    @responses.activate\n+    def test_retry_mechanism(self, payment_processor):\n+        \"\"\"Test retry mechanism on network failures.\"\"\"\n+        # First two attempts fail, third succeeds\n+        responses.add(\n+            responses.POST,\n+            \"https://api.paymentgateway.com/v1/charges\",\n+            body=responses.ConnectionError()\n+        )\n+        responses.add(\n+            responses.POST,\n+            \"https://api.paymentgateway.com/v1/charges\",\n+            body=responses.ConnectionError()\n+        )\n+        responses.add(\n+            responses.POST,\n+            \"https://api.paymentgateway.com/v1/charges\",\n+            json={\"id\": \"txn_retry_success\", \"status\": \"succeeded\"},\n+            status=200\n+        )\n+        \n+        with patch('logging.Logger.warning') as mock_warning:\n+            result = payment_processor.process_payment(\n+                amount=Decimal('50.00'),\n+                card_token='tok_test_card',\n+                customer_id='cust_retry_test'\n+            )\n+        \n+        assert result.success is True\n+        assert result.transaction_id == \"txn_retry_success\"\n+        assert mock_warning.call_count == 2  # Two retry warnings\n+    \n+    @responses.activate  \n+    def test_max_retries_exceeded(self, payment_processor):\n+        \"\"\"Test behavior when max retries are exceeded.\"\"\"\n+        # All attempts fail\n+        for _ in range(3):\n+            responses.add(\n+                responses.POST,\n+                \"https://api.paymentgateway.com/v1/charges\",\n+                body=responses.ConnectionError()\n+            )\n+        \n+        with patch('logging.Logger.error') as mock_error:\n+            result = payment_processor.process_payment(\n+                amount=Decimal('75.00'),\n+                card_token='tok_test_card',\n+                customer_id='cust_fail_test'\n+            )\n+        \n+        assert result.success is False\n+        assert result.transaction_id is None\n+        assert \"Payment failed after 3 attempts\" in result.error_message\n+        mock_error.assert_called_once()\n+    \n+    def test_idempotency_key_generation(self, payment_processor):\n+        \"\"\"Test that idempotency keys are generated correctly.\"\"\"\n+        with patch.object(payment_processor, '_attempt_payment') as mock_attempt:\n+            mock_attempt.return_value = PaymentResult(\n+                success=True, \n+                transaction_id=\"test_txn\"\n+            )\n+            \n+            payment_processor.process_payment(\n+                amount=Decimal('25.00'),\n+                card_token='tok_idempotent',\n+                customer_id='cust_idem_test'\n+            )\n+            \n+            # Verify the call was made with correct parameters\n+            mock_attempt.assert_called_once_with(\n+                Decimal('25.00'),\n+                'tok_idempotent',\n+                'cust_idem_test'\n+            )\n+\n+@pytest.mark.integration\n+class TestPaymentIntegration:\n+    \"\"\"Integration tests for payment processing.\"\"\"\n+    \n+    def test_end_to_end_payment_flow(self):\n+        \"\"\"Test complete payment flow from order to confirmation.\"\"\"\n+        # This would test the full integration with order service\n+        # Implementation depends on your specific architecture\n+        pass"
  },
  {
    "filename": "database/migrations/003_add_order_tracking.sql",
    "status": "added",
    "additions": 32,
    "deletions": 0,
    "diff": "@@ -0,0 +1,32 @@\n+-- Migration: Add order tracking and status updates\n+-- Date: 2023-12-01\n+-- Description: Adds order tracking capabilities with status history\n+\n+-- Add order status tracking table\n+CREATE TABLE order_status_history (\n+    id SERIAL PRIMARY KEY,\n+    order_id INTEGER NOT NULL REFERENCES orders(id) ON DELETE CASCADE,\n+    status VARCHAR(50) NOT NULL,\n+    comment TEXT,\n+    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n+    created_by INTEGER REFERENCES users(id)\n+);\n+\n+-- Add tracking number to orders\n+ALTER TABLE orders \n+ADD COLUMN tracking_number VARCHAR(100) UNIQUE,\n+ADD COLUMN estimated_delivery DATE,\n+ADD COLUMN actual_delivery TIMESTAMP;\n+\n+-- Create index for efficient status queries\n+CREATE INDEX idx_order_status_history_order_id ON order_status_history(order_id);\n+CREATE INDEX idx_order_status_history_status ON order_status_history(status);\n+CREATE INDEX idx_orders_tracking_number ON orders(tracking_number) WHERE tracking_number IS NOT NULL;\n+\n+-- Insert initial status for existing orders\n+INSERT INTO order_status_history (order_id, status, comment, created_at)\n+SELECT \n+    id, \n+    status, \n+    'Initial status from migration',\n+    created_at\n+FROM orders \n+WHERE status IS NOT NULL;\n+\n+-- Add trigger to automatically create status history entries\n+CREATE OR REPLACE FUNCTION create_order_status_history()\n+RETURNS TRIGGER AS $$\n+BEGIN\n+    IF OLD.status IS DISTINCT FROM NEW.status THEN\n+        INSERT INTO order_status_history (order_id, status, created_at)\n+        VALUES (NEW.id, NEW.status, CURRENT_TIMESTAMP);\n+    END IF;\n+    RETURN NEW;\n+END;\n+$$ LANGUAGE plpgsql;\n+\n+CREATE TRIGGER order_status_change_trigger\n+    AFTER UPDATE OF status ON orders\n+    FOR EACH ROW\n+    EXECUTE FUNCTION create_order_status_history();"
  }
]
